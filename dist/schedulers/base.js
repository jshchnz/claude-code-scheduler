/**
 * Abstract base class for platform-specific schedulers
 */
export class BaseScheduler {
    /**
     * Generate the command to execute Claude in non-interactive mode
     */
    getExecutionCommand(task) {
        const command = task.execution.command;
        // Escape the command for shell execution
        const escapedCommand = command.replace(/"/g, '\\"');
        // Build the claude command
        // Note: timeout is handled by the native scheduler, not Claude CLI
        // The -p flag enables non-interactive print mode
        const flags = [];
        if (task.execution.skipPermissions) {
            flags.push('--dangerously-skip-permissions');
        }
        const flagStr = flags.length > 0 ? ` ${flags.join(' ')}` : '';
        return `claude -p "${escapedCommand}"${flagStr}`;
    }
    /**
     * Get the working directory for a task
     */
    getWorkingDirectory(task) {
        return task.execution.workingDirectory || '.';
    }
    /**
     * Extract cron expression from task trigger
     */
    getCronExpression(task) {
        if (task.trigger.type !== 'cron') {
            throw new Error(`Unsupported trigger type: ${task.trigger.type}`);
        }
        return task.trigger.expression;
    }
    /**
     * Get the task label/identifier for the native scheduler
     */
    getTaskLabel(taskId) {
        return `com.claude.scheduler.${taskId}`;
    }
    /**
     * Check if task uses worktree execution
     */
    usesWorktree(task) {
        return task.execution.worktree?.enabled === true;
    }
    /**
     * Generate a shell script for git worktree-based execution
     * Returns null if worktree is not enabled
     */
    generateWorktreeScript(task, logDir) {
        const config = task.execution.worktree;
        if (!config?.enabled) {
            return null;
        }
        const mainRepo = this.getWorkingDirectory(task);
        const command = this.getExecutionCommand(task);
        const branchPrefix = config.branchPrefix || 'claude-task/';
        const remoteName = config.remoteName || 'origin';
        const basePath = config.basePath || '';
        return `#!/bin/bash
set -e

# Task: ${task.name} (${task.id})
# Generated by claude-code-scheduler

MAIN_REPO="${mainRepo}"
TASK_ID="${task.id}"
TASK_NAME="${task.name}"
TIMESTAMP=$(date +%s)
WORKTREE_NAME="task-\${TASK_ID:0:8}-\$TIMESTAMP"
BRANCH_PREFIX="${branchPrefix}"
REMOTE="${remoteName}"
LOG_DIR="${logDir}"

# Resolve main repo to absolute path
if [[ ! "$MAIN_REPO" = /* ]]; then
  MAIN_REPO="$(pwd)/$MAIN_REPO"
fi
MAIN_REPO=$(cd "$MAIN_REPO" && pwd)

# Verify git repo
if [ ! -d "$MAIN_REPO/.git" ]; then
  echo "Error: Not a git repository: $MAIN_REPO" >&2
  exit 1
fi

# Determine worktree base path
${basePath ? `WORKTREE_BASE="${basePath}"` : `WORKTREE_BASE="$(dirname "$MAIN_REPO")/.\$(basename "$MAIN_REPO")-worktrees"`}
WORKTREE_PATH="$WORKTREE_BASE/$WORKTREE_NAME"
BRANCH_NAME="\${BRANCH_PREFIX}\${WORKTREE_NAME}"

echo "Creating worktree at: $WORKTREE_PATH"

# Create worktree base directory
mkdir -p "$WORKTREE_BASE"

# Create git worktree with new branch
git -C "$MAIN_REPO" worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME"

# Execute Claude in the worktree
cd "$WORKTREE_PATH"
echo "Executing Claude in: $WORKTREE_PATH"
CLAUDE_EXIT=0
${command} || CLAUDE_EXIT=$?

echo "Claude exited with code: $CLAUDE_EXIT"

# Commit and push changes
COMMIT_MSG="Claude task: $TASK_NAME [$TASK_ID]"
PUSHED=false
HAS_CHANGES=false

git add -A
if ! git diff --cached --quiet; then
  HAS_CHANGES=true
  git commit -m "$COMMIT_MSG"
  if git push -u "$REMOTE" "$BRANCH_NAME"; then
    PUSHED=true
    echo "Changes pushed to $REMOTE/$BRANCH_NAME"
  else
    echo "Warning: Failed to push changes" >&2
  fi
else
  echo "No changes to commit"
fi

# Cleanup: remove worktree if push succeeded or no changes
if [ "$PUSHED" = "true" ] || [ "$HAS_CHANGES" = "false" ]; then
  echo "Cleaning up worktree..."
  cd "$MAIN_REPO"
  git worktree remove "$WORKTREE_PATH" --force || true
  echo "Worktree removed"
else
  echo "Keeping worktree at $WORKTREE_PATH for manual review (push failed)"
fi

exit $CLAUDE_EXIT
`;
    }
}
/**
 * Error thrown when scheduler operations fail
 */
export class SchedulerError extends Error {
    platform;
    operation;
    cause;
    constructor(message, platform, operation, cause) {
        super(message);
        this.platform = platform;
        this.operation = operation;
        this.cause = cause;
        this.name = 'SchedulerError';
    }
}
//# sourceMappingURL=base.js.map