import type { ScheduledTask, CronTrigger } from '../types.js';
import { shellEscape, sanitizeForComment } from '../utils/shell.js';

/**
 * Status of the native scheduler
 */
export interface SchedulerStatus {
  healthy: boolean;
  taskCount: number;
  errors: string[];
  platform: string;
}

/**
 * Abstract base class for platform-specific schedulers
 */
export abstract class BaseScheduler {
  /**
   * Human-readable name of the scheduler
   */
  abstract readonly name: string;

  /**
   * Platform identifier
   */
  abstract readonly platform: string;

  /**
   * Register a cron task with the native scheduler
   */
  abstract register(task: ScheduledTask): Promise<void>;

  /**
   * Unregister a task from the native scheduler
   */
  abstract unregister(taskId: string): Promise<void>;

  /**
   * Check if a task is registered
   */
  abstract isRegistered(taskId: string): Promise<boolean>;

  /**
   * Get current scheduler status
   */
  abstract getStatus(): Promise<SchedulerStatus>;

  /**
   * List all registered task IDs
   */
  abstract listRegistered(): Promise<string[]>;

  /**
   * Generate the command to execute Claude in non-interactive mode
   *
   * Security: Uses single quotes for the prompt to prevent shell expansion
   * of backticks, $(), and other shell metacharacters.
   */
  protected getExecutionCommand(task: ScheduledTask): string {
    const command = task.execution.command;

    // Use shellEscape to wrap in single quotes (prevents all shell expansion)
    const escapedCommand = shellEscape(command);

    // Build the claude command
    // Note: timeout is handled by the native scheduler, not Claude CLI
    // The -p flag enables non-interactive print mode
    const flags: string[] = [];
    if (task.execution.skipPermissions) {
      flags.push('--dangerously-skip-permissions');
    }

    const flagStr = flags.length > 0 ? ` ${flags.join(' ')}` : '';
    return `claude -p ${escapedCommand}${flagStr}`;
  }

  /**
   * Get the working directory for a task
   */
  protected getWorkingDirectory(task: ScheduledTask): string {
    return task.execution.workingDirectory || '.';
  }

  /**
   * Extract cron expression from task trigger
   */
  protected getCronExpression(task: ScheduledTask): string {
    if (task.trigger.type !== 'cron') {
      throw new Error(`Unsupported trigger type: ${task.trigger.type}`);
    }
    return (task.trigger as CronTrigger).expression;
  }

  /**
   * Get the task label/identifier for the native scheduler
   */
  protected getTaskLabel(taskId: string): string {
    return `com.claude.scheduler.${taskId}`;
  }

  /**
   * Check if task uses worktree execution
   */
  protected usesWorktree(task: ScheduledTask): boolean {
    return task.execution.worktree?.enabled === true;
  }

  /**
   * Generate a shell script for git worktree-based execution
   * Returns null if worktree is not enabled
   *
   * Security: All user-provided values are escaped using shellEscape()
   * to prevent command injection attacks.
   */
  protected generateWorktreeScript(task: ScheduledTask, logDir: string): string | null {
    const config = task.execution.worktree;
    if (!config?.enabled) {
      return null;
    }

    // Escape all user-provided values for safe shell embedding
    const mainRepoEsc = shellEscape(this.getWorkingDirectory(task));
    const taskIdEsc = shellEscape(task.id);
    const taskNameEsc = shellEscape(task.name);
    const branchPrefixEsc = shellEscape(config.branchPrefix || 'claude-task/');
    const remoteNameEsc = shellEscape(config.remoteName || 'origin');
    const logDirEsc = shellEscape(logDir);

    // Sanitize task name for comment (strip anything that could break comment)
    const commentSafeName = sanitizeForComment(task.name);

    // Base path handling - either escaped user value or computed default
    const basePathLine = config.basePath
      ? `WORKTREE_BASE=${shellEscape(config.basePath)}`
      : 'WORKTREE_BASE="$(dirname "$MAIN_REPO")/.$(basename "$MAIN_REPO")-worktrees"';

    // The command is already formatted for shell execution by getExecutionCommand()
    // It handles escaping of the user prompt. We embed it directly as a command.
    const command = this.getExecutionCommand(task);

    return `#!/bin/bash
set -e

# Task: ${commentSafeName} (${task.id})
# Generated by claude-code-scheduler

MAIN_REPO=${mainRepoEsc}
TASK_ID=${taskIdEsc}
TASK_NAME=${taskNameEsc}
TIMESTAMP=$(date +%s)
WORKTREE_NAME="task-\${TASK_ID:0:8}-\$TIMESTAMP"
BRANCH_PREFIX=${branchPrefixEsc}
REMOTE=${remoteNameEsc}
LOG_DIR=${logDirEsc}

# Resolve main repo to absolute path
if [[ ! "$MAIN_REPO" = /* ]]; then
  MAIN_REPO="$(pwd)/$MAIN_REPO"
fi
MAIN_REPO=$(cd "$MAIN_REPO" && pwd)

# Verify git repo
if [ ! -d "$MAIN_REPO/.git" ]; then
  echo "Error: Not a git repository: $MAIN_REPO" >&2
  exit 1
fi

# Determine worktree base path
${basePathLine}
WORKTREE_PATH="$WORKTREE_BASE/$WORKTREE_NAME"
BRANCH_NAME="\${BRANCH_PREFIX}\${WORKTREE_NAME}"

echo "Creating worktree at: $WORKTREE_PATH"

# Create worktree base directory
mkdir -p "$WORKTREE_BASE"

# Create git worktree with new branch
git -C "$MAIN_REPO" worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME"

# Execute Claude in the worktree
cd "$WORKTREE_PATH"
echo "Executing Claude in: $WORKTREE_PATH"
CLAUDE_EXIT=0
${command} || CLAUDE_EXIT=$?

echo "Claude exited with code: $CLAUDE_EXIT"

# Commit and push changes
COMMIT_MSG="Claude task: $TASK_NAME [$TASK_ID]"
PUSHED=false
HAS_CHANGES=false

git add -A
if ! git diff --cached --quiet; then
  HAS_CHANGES=true
  git commit -m "$COMMIT_MSG"
  if git push -u "$REMOTE" "$BRANCH_NAME"; then
    PUSHED=true
    echo "Changes pushed to $REMOTE/$BRANCH_NAME"
  else
    echo "Warning: Failed to push changes" >&2
  fi
else
  echo "No changes to commit"
fi

# Cleanup: remove worktree if push succeeded or no changes
if [ "$PUSHED" = "true" ] || [ "$HAS_CHANGES" = "false" ]; then
  echo "Cleaning up worktree..."
  cd "$MAIN_REPO"
  git worktree remove "$WORKTREE_PATH" --force || true
  echo "Worktree removed"
else
  echo "Keeping worktree at $WORKTREE_PATH for manual review (push failed)"
fi

exit $CLAUDE_EXIT
`;
  }
}

/**
 * Error thrown when scheduler operations fail
 */
export class SchedulerError extends Error {
  constructor(
    message: string,
    public readonly platform: string,
    public readonly operation: string,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'SchedulerError';
  }
}
