import type { ScheduledTask, CronTrigger } from '../types.js';

/**
 * Status of the native scheduler
 */
export interface SchedulerStatus {
  healthy: boolean;
  taskCount: number;
  errors: string[];
  platform: string;
}

/**
 * Abstract base class for platform-specific schedulers
 */
export abstract class BaseScheduler {
  /**
   * Human-readable name of the scheduler
   */
  abstract readonly name: string;

  /**
   * Platform identifier
   */
  abstract readonly platform: string;

  /**
   * Register a cron task with the native scheduler
   */
  abstract register(task: ScheduledTask): Promise<void>;

  /**
   * Unregister a task from the native scheduler
   */
  abstract unregister(taskId: string): Promise<void>;

  /**
   * Check if a task is registered
   */
  abstract isRegistered(taskId: string): Promise<boolean>;

  /**
   * Get current scheduler status
   */
  abstract getStatus(): Promise<SchedulerStatus>;

  /**
   * List all registered task IDs
   */
  abstract listRegistered(): Promise<string[]>;

  /**
   * Generate the command to execute Claude in non-interactive mode
   */
  protected getExecutionCommand(task: ScheduledTask): string {
    const command = task.execution.command;

    // Escape the command for shell execution
    const escapedCommand = command.replace(/"/g, '\\"');

    // Build the claude command
    // Note: timeout is handled by the native scheduler, not Claude CLI
    // The -p flag enables non-interactive print mode
    const flags: string[] = [];
    if (task.execution.skipPermissions) {
      flags.push('--dangerously-skip-permissions');
    }

    const flagStr = flags.length > 0 ? ` ${flags.join(' ')}` : '';
    return `claude -p "${escapedCommand}"${flagStr}`;
  }

  /**
   * Get the working directory for a task
   */
  protected getWorkingDirectory(task: ScheduledTask): string {
    return task.execution.workingDirectory || '.';
  }

  /**
   * Extract cron expression from task trigger
   */
  protected getCronExpression(task: ScheduledTask): string {
    if (task.trigger.type !== 'cron') {
      throw new Error(`Unsupported trigger type: ${task.trigger.type}`);
    }
    return (task.trigger as CronTrigger).expression;
  }

  /**
   * Get the task label/identifier for the native scheduler
   */
  protected getTaskLabel(taskId: string): string {
    return `com.claude.scheduler.${taskId}`;
  }

  /**
   * Check if task uses worktree execution
   */
  protected usesWorktree(task: ScheduledTask): boolean {
    return task.execution.worktree?.enabled === true;
  }

  /**
   * Generate a shell script for git worktree-based execution
   * Returns null if worktree is not enabled
   */
  protected generateWorktreeScript(task: ScheduledTask, logDir: string): string | null {
    const config = task.execution.worktree;
    if (!config?.enabled) {
      return null;
    }

    const mainRepo = this.getWorkingDirectory(task);
    const command = this.getExecutionCommand(task);
    const branchPrefix = config.branchPrefix || 'claude-task/';
    const remoteName = config.remoteName || 'origin';
    const basePath = config.basePath || '';

    return `#!/bin/bash
set -e

# Task: ${task.name} (${task.id})
# Generated by claude-code-scheduler

MAIN_REPO="${mainRepo}"
TASK_ID="${task.id}"
TASK_NAME="${task.name}"
TIMESTAMP=$(date +%s)
WORKTREE_NAME="task-\${TASK_ID:0:8}-\$TIMESTAMP"
BRANCH_PREFIX="${branchPrefix}"
REMOTE="${remoteName}"
LOG_DIR="${logDir}"

# Resolve main repo to absolute path
if [[ ! "$MAIN_REPO" = /* ]]; then
  MAIN_REPO="$(pwd)/$MAIN_REPO"
fi
MAIN_REPO=$(cd "$MAIN_REPO" && pwd)

# Verify git repo
if [ ! -d "$MAIN_REPO/.git" ]; then
  echo "Error: Not a git repository: $MAIN_REPO" >&2
  exit 1
fi

# Determine worktree base path
${basePath ? `WORKTREE_BASE="${basePath}"` : `WORKTREE_BASE="$(dirname "$MAIN_REPO")/.\$(basename "$MAIN_REPO")-worktrees"`}
WORKTREE_PATH="$WORKTREE_BASE/$WORKTREE_NAME"
BRANCH_NAME="\${BRANCH_PREFIX}\${WORKTREE_NAME}"

echo "Creating worktree at: $WORKTREE_PATH"

# Create worktree base directory
mkdir -p "$WORKTREE_BASE"

# Create git worktree with new branch
git -C "$MAIN_REPO" worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME"

# Execute Claude in the worktree
cd "$WORKTREE_PATH"
echo "Executing Claude in: $WORKTREE_PATH"
CLAUDE_EXIT=0
${command} || CLAUDE_EXIT=$?

echo "Claude exited with code: $CLAUDE_EXIT"

# Commit and push changes
COMMIT_MSG="Claude task: $TASK_NAME [$TASK_ID]"
PUSHED=false
HAS_CHANGES=false

git add -A
if ! git diff --cached --quiet; then
  HAS_CHANGES=true
  git commit -m "$COMMIT_MSG"
  if git push -u "$REMOTE" "$BRANCH_NAME"; then
    PUSHED=true
    echo "Changes pushed to $REMOTE/$BRANCH_NAME"
  else
    echo "Warning: Failed to push changes" >&2
  fi
else
  echo "No changes to commit"
fi

# Cleanup: remove worktree if push succeeded or no changes
if [ "$PUSHED" = "true" ] || [ "$HAS_CHANGES" = "false" ]; then
  echo "Cleaning up worktree..."
  cd "$MAIN_REPO"
  git worktree remove "$WORKTREE_PATH" --force || true
  echo "Worktree removed"
else
  echo "Keeping worktree at $WORKTREE_PATH for manual review (push failed)"
fi

exit $CLAUDE_EXIT
`;
  }
}

/**
 * Error thrown when scheduler operations fail
 */
export class SchedulerError extends Error {
  constructor(
    message: string,
    public readonly platform: string,
    public readonly operation: string,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'SchedulerError';
  }
}
